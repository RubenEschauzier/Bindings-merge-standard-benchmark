"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfJsQuadSource = void 0;
const metadata_1 = require("@comunica/metadata");
const asynciterator_1 = require("asynciterator");
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_terms_1 = require("rdf-terms");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A quad source that wraps over an {@link RDF.Source}.
 */
class RdfJsQuadSource {
    constructor(source) {
        this.source = source;
    }
    static nullifyVariables(term, quotedTripleFiltering) {
        return !term || term.termType === 'Variable' || (!quotedTripleFiltering &&
            term.termType === 'Quad' && (0, rdf_terms_1.someTermsNested)(term, value => value.termType === 'Variable')) ?
            undefined :
            term;
    }
    static hasDuplicateVariables(pattern) {
        const variables = (0, rdf_terms_1.filterTermsNested)(pattern, term => term.termType === 'Variable');
        return variables.length > 1 && (0, rdf_terms_1.uniqTerms)(variables).length < variables.length;
    }
    match(subject, predicate, object, graph) {
        // Check if the source supports quoted triple filtering
        const quotedTripleFiltering = Boolean(this.source.features?.quotedTripleFiltering);
        // Create an async iterator from the matched quad stream
        const rawStream = this.source.match(RdfJsQuadSource.nullifyVariables(subject, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(predicate, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(object, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(graph, quotedTripleFiltering));
        let it = (0, asynciterator_1.wrap)(rawStream, { autoStart: false });
        // Perform post-match-filtering if the source does not support quoted triple filtering,
        // but we have a variable inside a quoted triple.
        const pattern = DF.quad(subject, predicate, object, graph);
        if (!quotedTripleFiltering && (0, rdf_terms_1.someTerms)(pattern, term => term.termType === 'Quad')) {
            it = it.filter(quad => (0, rdf_terms_1.matchPatternComplete)(quad, pattern));
        }
        // Determine metadata
        this.setMetadata(it, subject, predicate, object, graph)
            .catch(error => it.destroy(error));
        return it;
    }
    async setMetadata(it, subject, predicate, object, graph) {
        // Check if the source supports quoted triple filtering
        const quotedTripleFiltering = Boolean(this.source.features?.quotedTripleFiltering);
        let cardinality;
        if (this.source.countQuads) {
            // If the source provides a dedicated method for determining cardinality, use that.
            cardinality = await this.source.countQuads(RdfJsQuadSource.nullifyVariables(subject, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(predicate, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(object, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(graph, quotedTripleFiltering));
        }
        else {
            // Otherwise, fallback to a sub-optimal alternative where we just call match again to count the quads.
            // WARNING: we can NOT reuse the original data stream here,
            // because we may loose data elements due to things happening async.
            let i = 0;
            cardinality = await new Promise((resolve, reject) => {
                const matches = this.source.match(RdfJsQuadSource.nullifyVariables(subject, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(predicate, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(object, quotedTripleFiltering), RdfJsQuadSource.nullifyVariables(graph, quotedTripleFiltering));
                matches.on('error', reject);
                matches.on('end', () => resolve(i));
                matches.on('data', () => i++);
            });
        }
        // If `match` would require filtering afterwards, our count will be an over-estimate.
        const pattern = DF.quad(subject, predicate, object, graph);
        const wouldRequirePostFiltering = (!quotedTripleFiltering &&
            (0, rdf_terms_1.someTerms)(pattern, term => term.termType === 'Quad')) ||
            RdfJsQuadSource.hasDuplicateVariables(pattern);
        it.setProperty('metadata', {
            state: new metadata_1.MetadataValidationState(),
            cardinality: { type: wouldRequirePostFiltering ? 'estimate' : 'exact', value: cardinality },
            canContainUndefs: false,
        });
    }
}
exports.RdfJsQuadSource = RdfJsQuadSource;
//# sourceMappingURL=RdfJsQuadSource.js.map