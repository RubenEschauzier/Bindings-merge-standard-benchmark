"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationQuadpattern = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
const rdf_terms_1 = require("rdf-terms");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const BF = new bindings_factory_1.BindingsFactory();
const DF = new rdf_data_factory_1.DataFactory();
const AF = new sparqlalgebrajs_1.Factory();
/**
 * A comunica actor for handling 'quadpattern' query operations.
 */
class ActorQueryOperationQuadpattern extends bus_query_operation_1.ActorQueryOperationTyped {
    constructor(args) {
        super(args, 'pattern');
    }
    /**
     * Check if a term is a variable.
     * @param {RDF.Term} term An RDF term.
     * @return {any} If the term is a variable or blank node.
     */
    static isTermVariable(term) {
        return term.termType === 'Variable';
    }
    /**
     * Get all variables in the given pattern.
     * No duplicates are returned.
     * @param {RDF.BaseQuad} pattern A quad pattern.
     */
    static getVariables(pattern) {
        return (0, rdf_terms_1.uniqTerms)((0, rdf_terms_1.getTermsNested)(pattern)
            .filter(ActorQueryOperationQuadpattern.isTermVariable));
    }
    /**
     * A helper function to find a hash with quad elements that have duplicate variables.
     *
     * @param {RDF.Quad} pattern A quad pattern.
     *
     * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns undefined.
     *                                   Otherwise, this maps quad elements paths (['subject'], ['predicate'], ['object'],
     *                                   ['graph'])
     *                                   to the list of quad elements it shares a variable name with.
     *                                   For quoted triples, paths such as ['subject', 'object'] may occur.
     *                                   If no links for a certain element exist, this element will
     *                                   not be included in the hash.
     *                                   Note 1: Quad elements will never have a link to themselves.
     *                                           So this can never occur: { subject: [[ 'subject']] },
     *                                           instead 'null' would be returned.
     *                                   Note 2: Links only exist in one direction,
     *                                           this means that { subject: [[ 'predicate']], predicate: [[ 'subject' ]] }
     *                                           will not occur, instead only { subject: [[ 'predicate']] }
     *                                           will be returned.
     *                                   Note 3: Keys can also be paths, but they are delimited by '_', such as:
     *                                           { subject_object_subject: [[ 'predicate']] }
     */
    static getDuplicateElementLinks(pattern) {
        // Collect a variable to quad elements mapping.
        const variableElements = {};
        let duplicateVariables = false;
        (0, rdf_terms_1.forEachTermsNested)(pattern, (value, keys) => {
            if (value.termType === 'Variable') {
                const val = (0, rdf_string_1.termToString)(value);
                const length = (variableElements[val] || (variableElements[val] = [])).push(keys);
                duplicateVariables = duplicateVariables || length > 1;
            }
        });
        if (!duplicateVariables) {
            return;
        }
        // Collect quad element to elements with equal variables mapping.
        const duplicateElementLinks = {};
        for (const variable in variableElements) {
            const elements = variableElements[variable];
            const remainingElements = elements.slice(1);
            // Only store the elements that have at least one equal element.
            if (remainingElements.length > 0) {
                duplicateElementLinks[elements[0].join('_')] = remainingElements;
            }
        }
        return duplicateElementLinks;
    }
    /**
     * Ensure that the given raw metadata object contains all required metadata entries.
     * @param metadataRaw A raw metadata object.
     */
    static validateMetadata(metadataRaw) {
        for (const key of ['cardinality', 'canContainUndefs']) {
            if (!(key in metadataRaw)) {
                throw new Error(`Invalid metadata: missing ${key} in ${JSON.stringify(metadataRaw)}`);
            }
        }
        return metadataRaw;
    }
    /**
     * Get the metadata of the given action on a quad stream.
     *
     * @param {AsyncIterator<Quad>} data The data stream that is guaranteed to emit the metadata property.
     * @param elementVariables Mapping of quad term name to variable name.
     * @param variables Variables to include in the metadata
     * @return {() => Promise<{[p: string]: any}>} A lazy promise behind a callback resolving to a metadata object.
     */
    static getMetadata(data, elementVariables, variables) {
        return () => new Promise((resolve, reject) => {
            data.getProperty('metadata', (metadata) => resolve(metadata));
            data.on('error', reject);
        }).then(metadataRaw => {
            if (!('canContainUndefs' in metadataRaw)) {
                metadataRaw.canContainUndefs = false;
            }
            return ActorQueryOperationQuadpattern.quadsMetadataToBindingsMetadata(ActorQueryOperationQuadpattern.validateMetadata(metadataRaw), elementVariables, variables);
        });
    }
    static quadsMetadataToBindingsMetadata(metadataQuads, elementVariables, variables) {
        return {
            ...metadataQuads,
            order: metadataQuads.order ?
                ActorQueryOperationQuadpattern.quadsOrderToBindingsOrder(metadataQuads.order, elementVariables) :
                undefined,
            availableOrders: metadataQuads.availableOrders ?
                metadataQuads.availableOrders.map(orderDef => ({
                    cost: orderDef.cost,
                    terms: ActorQueryOperationQuadpattern.quadsOrderToBindingsOrder(orderDef.terms, elementVariables),
                })) :
                undefined,
            variables,
        };
    }
    static quadsOrderToBindingsOrder(quadsOrder, elementVariables) {
        const mappedVariables = {};
        return quadsOrder.map(entry => {
            // Omit entries that do not map to a variable
            const variableName = elementVariables[entry.term];
            if (!variableName) {
                return;
            }
            // Omit entries that have been mapped already
            if (mappedVariables[variableName]) {
                return;
            }
            mappedVariables[variableName] = true;
            return {
                term: DF.variable(variableName),
                direction: entry.direction,
            };
        }).filter(entry => Boolean(entry));
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(pattern, context) {
        // Apply the (optional) pattern-specific context
        if (pattern.context) {
            context = context.merge(pattern.context);
        }
        // Modify pattern with default graph when using union default graph semantics
        let patternInner = pattern;
        const unionDefaultGraph = this.unionDefaultGraph || context.get(context_entries_1.KeysQueryOperation.unionDefaultGraph);
        if (pattern.graph.termType === 'DefaultGraph' && unionDefaultGraph) {
            patternInner = AF.createPattern(pattern.subject, pattern.predicate, pattern.object, DF.variable('__comunica:defaultGraph'));
        }
        // Resolve the quad pattern
        const result = await this.mediatorResolveQuadPattern.mediate({ pattern: patternInner, context });
        // Collect all variables from the pattern
        const variables = ActorQueryOperationQuadpattern.getVariables(pattern);
        // Convenience datastructure for mapping quad elements to variables
        const elementVariables = (0, rdf_terms_1.reduceTermsNested)(pattern, (acc, term, keys) => {
            if (term.termType === 'Variable') {
                acc[keys.join('_')] = term.value;
            }
            return acc;
        }, {});
        // Create the metadata callback
        const metadata = ActorQueryOperationQuadpattern.getMetadata(result.data, elementVariables, variables);
        // Optionally filter, and construct bindings
        const bindingsStream = new bus_query_operation_1.ClosableTransformIterator(async () => {
            let filteredOutput = result.data;
            // Detect duplicate variables in the pattern
            const duplicateElementLinks = ActorQueryOperationQuadpattern
                .getDuplicateElementLinks(pattern);
            // SPARQL query semantics allow graph variables to only match with named graphs, excluding the default graph
            // But this is not the case when using union default graph semantics
            if (pattern.graph.termType === 'Variable' && !unionDefaultGraph) {
                filteredOutput = filteredOutput.filter(quad => quad.graph.termType !== 'DefaultGraph');
            }
            // If there are duplicate variables in the search pattern,
            // make sure that we filter out the triples that don't have equal values for those triple elements,
            // as the rdf-resolve-quad-pattern bus ignores variable names.
            if (duplicateElementLinks) {
                filteredOutput = filteredOutput.filter(quad => {
                    for (const keyLeft in duplicateElementLinks) {
                        const keysLeft = keyLeft.split('_');
                        const valueLeft = (0, rdf_terms_1.getValueNestedPath)(quad, keysLeft);
                        for (const keysRight of duplicateElementLinks[keyLeft]) {
                            if (!valueLeft.equals((0, rdf_terms_1.getValueNestedPath)(quad, keysRight))) {
                                return false;
                            }
                        }
                    }
                    return true;
                });
            }
            return filteredOutput.map(quad => BF.bindings(Object.keys(elementVariables).map(key => {
                const keys = key.split('_');
                const variable = elementVariables[key];
                const term = (0, rdf_terms_1.getValueNestedPath)(quad, keys);
                return [DF.variable(variable), term];
            })));
        }, {
            autoStart: false,
            onClose: () => result.data.destroy(),
        });
        return { type: 'bindings', bindingsStream, metadata };
    }
}
exports.ActorQueryOperationQuadpattern = ActorQueryOperationQuadpattern;
//# sourceMappingURL=ActorQueryOperationQuadpattern.js.map