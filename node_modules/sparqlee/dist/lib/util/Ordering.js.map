{"version":3,"file":"Ordering.js","sourceRoot":"","sources":["../../../lib/util/Ordering.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as LRUCache from 'lru-cache';\nimport type * as E from '../expressions';\nimport { regularFunctions } from '../functions';\nimport { TermTransformer } from '../transformers/TermTransformer';\nimport * as C from './Consts';\nimport * as Err from './Errors';\nimport type { SuperTypeCallback, TypeCache } from './TypeHandling';\n\n// Determine the relative numerical order of the two given terms.\n// In accordance with https://www.w3.org/TR/sparql11-query/#modOrderBy\n/**\n * @param enableExtendedXSDTypes System will behave like when this was true. @deprecated\n */\nexport function orderTypes(termA: RDF.Term | undefined, termB: RDF.Term | undefined,\n  strict = false,\n  typeDiscoveryCallback?: SuperTypeCallback, typeCache?: TypeCache, enableExtendedXSDTypes?: boolean): -1 | 0 | 1 {\n  // Check if terms are the same by reference\n  if (termA === termB) {\n    return 0;\n  }\n\n  // We handle undefined that is lower than everything else.\n  if (termA === undefined) {\n    return -1;\n  }\n  if (termB === undefined) {\n    return 1;\n  }\n\n  //\n  if (termA.termType !== termB.termType) {\n    return _TERM_ORDERING_PRIORITY[termA.termType] < _TERM_ORDERING_PRIORITY[termB.termType] ? -1 : 1;\n  }\n\n  // Check exact term equality\n  if (termA.equals(termB)) {\n    return 0;\n  }\n\n  // Handle quoted triples\n  if (termA.termType === 'Quad' && termB.termType === 'Quad') {\n    const orderSubject = orderTypes(\n      termA.subject, termB.subject, strict, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes,\n    );\n    if (orderSubject !== 0) {\n      return orderSubject;\n    }\n    const orderPredicate = orderTypes(\n      termA.predicate, termB.predicate, strict, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes,\n    );\n    if (orderPredicate !== 0) {\n      return orderPredicate;\n    }\n    const orderObject = orderTypes(\n      termA.object, termB.object, strict, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes,\n    );\n    if (orderObject !== 0) {\n      return orderObject;\n    }\n    return orderTypes(\n      termA.graph, termB.graph, strict, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes,\n    );\n  }\n\n  // Handle literals\n  if (termA.termType === 'Literal') {\n    return orderLiteralTypes(termA, <RDF.Literal>termB, typeDiscoveryCallback, typeCache);\n  }\n\n  // Handle all other types\n  if (strict) {\n    throw new Err.InvalidCompareArgumentTypes(termA, termB);\n  }\n  return comparePrimitives(termA.value, termB.value);\n}\n\nfunction orderLiteralTypes(litA: RDF.Literal, litB: RDF.Literal,\n  typeDiscoveryCallback?: SuperTypeCallback, typeCache?: TypeCache): -1 | 0 | 1 {\n  const isGreater = regularFunctions[C.RegularOperator.GT];\n  const isEqual = regularFunctions[C.RegularOperator.EQUAL];\n  const context = {\n    now: new Date(),\n    functionArgumentsCache: {},\n    superTypeProvider: {\n      discoverer: typeDiscoveryCallback || (() => 'term'),\n      cache: typeCache || new LRUCache(),\n    },\n    defaultTimeZone: { zoneHours: 0, zoneMinutes: 0 },\n  };\n\n  const termTransformer = new TermTransformer(context.superTypeProvider);\n  const myLitA = termTransformer.transformLiteral(litA);\n  const myLitB = termTransformer.transformLiteral(litB);\n\n  try {\n    if ((<E.BooleanLiteral> isEqual.apply([ myLitA, myLitB ], context)).typedValue) {\n      return 0;\n    }\n    if ((<E.BooleanLiteral> isGreater.apply([ myLitA, myLitB ], context)).typedValue) {\n      return 1;\n    }\n    return -1;\n  } catch {\n    // Fallback to string-based comparison\n    const compareType = comparePrimitives(myLitA.dataType, myLitB.dataType);\n    if (compareType !== 0) {\n      return compareType;\n    }\n    return comparePrimitives(myLitA.str(), myLitB.str());\n  }\n}\n\nfunction comparePrimitives(valueA: any, valueB: any): -1 | 0 | 1 {\n  // eslint-disable-next-line @typescript-eslint/no-extra-parens\n  return valueA === valueB ? 0 : (valueA < valueB ? -1 : 1);\n}\n\n// SPARQL specifies that blankNode < namedNode < literal.\nconst _TERM_ORDERING_PRIORITY = {\n  Variable: 0,\n  BlankNode: 1,\n  NamedNode: 2,\n  Literal: 3,\n  Quad: 4,\n  DefaultGraph: 5,\n};\n"]}